"""Tools for manging shotgrid versions."""

import logging
import pprint

from pini import pipe, qt
from pini.utils import Seq, get_user, File, TMP, Video, Image, strftime, single

from . import sg_utils, sg_handler, sg_pub_file

_LOGGER = logging.getLogger(__name__)


def create_ver(
        render, frames=None, comment=None, thumb=None, filmstrip=None,
        pub_files=(), force=False):
    """Register the given render in shotgrid.

    Args:
        render (CPOutputVideo|CPOutputSeq): output to register
        frames (CPOutputSeq): source frames
        comment (str): submission comment
        thumb (File): override thumbnail
        filmstrip (File): override filmstrip
        pub_files (CPOutput list): published files to link
        force (bool): force re-register if already exists

    Returns:
        (SGVersion): version
    """
    from pini.pipe import shotgrid
    _progress = qt.progress_dialog(
        'Submitting version', col='Orchid', stack_key='SubmitVersion')
    _LOGGER.info('CREATE VERSION')

    _pub_files = set(pub_files)
    _render, _video, _frames = _read_render_video_frames(
        render=render, frames=frames, pub_files=_pub_files)
    _progress.set_pc(10)
    _comment = comment
    _ety = _render.entity.sg_entity

    # Check for existing
    _sg_ver = _ety.find_ver(_render, catch=True)
    if not force and _sg_ver:
        _LOGGER.info(' - VERSION ALREADY EXISTS %s', _render)
        _progress.set_pc(100)
        return _sg_ver
    _progress.set_pc(15)

    # Read work
    _work = _render.find_work()
    if _work:
        _pub_files.add(_work)
        for _path in sorted(_work.metadata.get('refs', {}).values()):
            _out = pipe.CACHE.obt_output(_path, catch=True)
            if _out:
                _pub_files.add(_out)
        _comment = _comment or _work.notes
    _progress.set_pc(20)

    # Create version
    _sg_ver = _obt_ver_elem(
        version=_sg_ver, frames=_frames, pub_files=sorted(_pub_files),
        render=_render, comment=_comment, progress=_progress)
    _progress.set_pc(50)

    # Upload video
    if _video:
        shotgrid.upload(
            'Version', _sg_ver.id_, _video, field_name='sg_uploaded_movie')
    _progress.set_pc(60)

    # Apply thumb
    _apply_thumb(thumb=thumb, version=_sg_ver, render=_render, video=_video)
    _progress.set_pc(70)

    # Apply filmstrip (generated automatically if thumb)
    if filmstrip:
        _strip = File(filmstrip)
        shotgrid.upload_filmstrip_thumbnail(
            'Version', _sg_ver.id_, _strip.path)
    _progress.set_pc(80)

    if _work:
        _work.add_metadata(submitted=True)
    _progress.set_pc(90)

    _add_to_dailies_playlist(render=_render, version=_sg_ver)
    _progress.set_pc(100)

    return _sg_ver


def _add_to_dailies_playlist(render, version, catch=True):
    """Add this version to next dailies playlist.

    If the playlist is marked as closed, the next index is used.

    Args:
        render (CCPOutputBase): render being submitted
        version (SGCVersion): shotgrid version
        catch (bool): no error if fail to add to playlist
    """
    _LOGGER.info(' - APPLY DAILIES PLAYLIST')
    _ety = render.entity
    _job = render.job
    if version.data['playlists']:
        _list = single(version.data['playlists'])['name']
        if catch:
            return
        raise RuntimeError(
            f'Already in {_job.name} playlist {_list} - {render.base}')

    _type = version.data['sg_version_type']
    if not _type:
        raise RuntimeError(
            f'Missing version type data {version.id_} - {render.path}')

    # Find today's playlists for this type
    _prefix = (
        f'{strftime("%Y%m%d")}_{_ety.entity_type}.{_ety.name}_{_type}Dailies')
    _playlists = {
        _item['code']: _item for _item in sg_handler.find(
            'Playlist', job=render.job, fields=['code', 'sg_status'],
            filters=[('code', 'starts_with', _prefix)])}

    # Find next open playlist
    _create = False
    _playlist = None
    for _idx in range(1, 100):
        _name = f'{_prefix}_{_idx:02d}'
        _LOGGER.info('CHECK NAME %s', _name)
        if _name not in _playlists:
            _create = True
            break
        _playlist = _playlists[_name]
        if _playlist['sg_status'] != 'clsd':
            break
    else:
        raise RuntimeError(f'Overflow {_prefix} - {_ety.path}')

    # Create or add to playlist
    if _create:
        _LOGGER.info(' - CREATE PLAYLIST %s', _name)
        _desc = (
            'Automatic daily playlist generated by pini. After '
            'reviewing, change the playlist status to Closed and a new '
            f'version will be generated ie. {_name} -> '
            f'{_prefix}_{_idx + 1:02d}')
        _data = {
            'code': _name,
            'description': _desc,
            'project': _ety.job.sg_proj.to_entry(),
            'versions': [version.to_entry()]}
        sg_handler.create('Playlist', _data)
    else:
        _LOGGER.info(' - ADD TO %s', _name)
        assert _playlist
        sg_handler.update(
            'Version', version.id_, data={'playlists': [_playlist]})


def _apply_thumb(thumb, version, render, video):
    """Apply version thumbnail.

    Args:
        thumb (str): path to thumbnail
        version (SGCVersion): version
        render (CCPOutputBase): render
        video (CCPOutputVideo): video
    """
    _LOGGER.info(' - APPLY THUMB %s', thumb)
    _LOGGER.info('   - VIDEO %s', video)

    # Determine thumb path
    _thumb = None
    if thumb:
        _thumb = File(_thumb)
    if not _thumb and isinstance(render, Seq):
        _thumb = render.to_frame_file()
    if not _thumb and video:
        _thumb = TMP.to_file('tmp.jpg')
        render.to_frame(_thumb, force=True)
        _LOGGER.info(' - APPLY THUMB FROM VIDEO %s', _thumb)

    # Fix exr thumb
    if _thumb and _thumb.extn == 'exr':
        _tmp = TMP.to_file('tmp.jpg')
        Image(_thumb).convert(_tmp, force=True)
        _thumb = _tmp

    # Apply thumb
    _LOGGER.info('   - THUMB %s', _thumb)
    if _thumb:
        assert _thumb.exists()
        sg_handler.upload_thumbnail('Version', version.id_, _thumb.path)


def _build_ver_data(render, frames, comment, pub_files):
    """Build version data dict.

    Args:
        render (CPOutputBase): output to register
        frames (CPOutputSeq): source frames
        comment (str): submission comment
        pub_files (CPOutput list): published files to link

    Returns:
        (dict): version data
    """
    from pini.pipe import shotgrid

    _work = sg_utils.output_to_work(render)
    _sg_ety = shotgrid.SGC.find_entity(render.entity)
    _sg_job = shotgrid.SGC.find_proj(render.job)
    _sg_task = _sg_ety.find_task(task=render.task, step=render.step)

    # Build data
    _data = {
        "code": render.base,
        "entity": _sg_ety.to_entry(),
        "project": _sg_job.to_entry(),
        "sg_task": _sg_task.to_entry(),
        "sg_path_to_movie": render.path,
        "sg_version_number": render.ver_n,
    }
    if 'sg_pini_tag' in shotgrid.find_fields('Version'):
        _data["sg_pini_tag"] = render.tag or ''

    # Add version type
    _map = {
        'model': 'model',
        'rig': 'rig',
        'lookdev': 'surf',
    }
    if render.pini_task in _map:
        _data['sg_version_type'] = _map[render.pini_task]

    # Add frames data
    if frames:
        assert isinstance(frames, Seq)
        _start, _end = frames.to_range(force=True)
        _data['sg_path_to_frames'] = frames.path
        _data['sg_first_frame'] = _start
        _data['sg_last_frame'] = _end

    # Add user data
    _user = render.metadata.get('owner') or get_user()
    if _user:
        _sg_user = shotgrid.SGC.find_user(_user)
        _data['user'] = _sg_user.to_entry()
        _data['created_by'] = _sg_user.to_entry()

    # Add description
    _desc = comment
    if not _desc and _work:
        _desc = _work.notes
    if _desc:
        _data['description'] = _desc

    # Add published files
    if pub_files:
        _pub_files = sorted(set(pub_files) | {render})
        _LOGGER.info(' - PUB FILES %s', _pub_files)
        _data['published_files'] = []
        for _pub_file in _pub_files:
            if isinstance(_pub_file, dict):
                _pub_file_data = _pub_file
            elif isinstance(_pub_file, pipe.CPOutputFile):
                _out = pipe.CACHE.obt(_pub_file)
                _pub_file_data = _out.sg_pub_file.to_entry()
            else:
                _pub_file_data = sg_pub_file.create_pub_file_from_path(
                    _pub_file.path)
            _data['published_files'].append(_pub_file_data)

    return _data


def _obt_ver_elem(version, render, frames, comment, pub_files, progress):
    """Obtain version element.

    Args:
        version (SGCVersion): existing version (if any)
        render (CCPOutputBase): render
        frames (CCPOutputSeq): source frames
        comment (str): comment
        pub_files (list): publish files to link
        progress (ProgressDialog): progress dialog

    Returns:
        (SGCVersion): version
    """
    _ety = render.entity.sg_entity

    # Build submit data
    _data = _build_ver_data(
        render, frames=frames, comment=comment, pub_files=pub_files)
    _LOGGER.debug('DATA %s', pprint.pformat(_data))
    progress.set_pc(30)

    # Create or update shotgrid
    if not version:
        sg_handler.create('Version', _data)
        _action = 'CREATED'
    else:
        _data.pop('created_by')
        sg_handler.update('Version', version.id_, _data)
        _action = 'UPDATED'

    # Find updated element
    progress.set_pc(40)
    _sg_ver = _ety.find_ver(render, force=True)
    _LOGGER.info(' - %s VERSION %s', _action, _sg_ver)
    assert _sg_ver

    return _sg_ver


def _read_render_video_frames(render, frames, pub_files):
    """Read render, video and frames from submit args.

    If an image sequence with more than one frame is submitted, it is converted
    to a video using ffmpeg.

    Args:
        render (CPOutputSeq|CPOutputVideo): render arg
        frames (CPOutputSeq): render frames
        pub_files (set): pub files list

    Returns:
        (tuple): render, video, frames
    """
    _video = None
    _frames = frames
    _render = pipe.CACHE.obt(render)

    if isinstance(_render, Video):
        return _render, _render, _frames

    if isinstance(_render, Seq):
        assert not _frames

        # Single still image
        if len(_render.frames) == 1:
            return _render, None, _render

        _frames = _render

        # Render video
        _video = _frames.to_output('mov', extn='mov')
        if not _video.exists():
            _work = _render.find_work()
            _fps = _work.metadata.get('fps') or _work.entity.settings.get('fps')
            _frames.to_video(_video, fps=_fps)
            assert _video.exists()
            _video.set_metadata(_render.metadata)
            sg_pub_file.create_pub_file_from_output(
                _video, upstream_files=[_frames])
            pub_files.add(_frames)

        return _render, _video, _frames

    raise NotImplementedError(render, frames)
